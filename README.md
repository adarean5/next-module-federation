# NextJS module federation

This is a sample project that attempts to introduce webpack module federation to NextJS projects.

## Prerequisites
- node v18
- pnpm v8 - https://pnpm.io/installation

## Setup

Run `pnpm install` in the root of the project to install dependencies.

Run `turbo dev` in the root of the project to start the dev servers for the shell and the micro-frontends.
Open http://localhost:4000 to access the shell and http://localhost/4001 to access the micro-frontend root directly.

## The module federation configuration

Inside the `apps` workspace there are two separate NextJS projects:
- `shell`: Acts as the main entry point for micro-frontends
- `mf-one`: A micro-frontend that exposes multiple components that can be consumed in the shell via module federation

Module federation for each project is configured in the `next.config.js` file in the root of each project.

### mf-one

mf-one's next.config.js contains a `federationConfig` object, which contains the following properties:
- `name`: The name of the micro-frontend that can be used in other module federation project to reference it
- `filename`: the entry file that will be generated by the module fedration plugin and consumed by other projects
  -  After building or running the dev server, you can find the output in `.next/static/chunks/remoteEntry.js` (the path defined in the config)
      Interestingly enough the plugin automatically creates one more `remoteEntry.js` file in `.next/static/ssr`
- `exposes`: key-value pairs, where each value is a path to a component we want to expose and the key, 
  which will be used in the shell to import the component via module federation

The nextConfig contains a custom webpack config.
Two plugins are configured:
- `NextFederationPlugin` - Enables module federation in a NextJS project
- `FederatedTypesPlugin` - Generates types for the exposed components that can be used in the shell project

Both plugins use the same configuration described above.

### shell

The shell's `next.config.js` contains a function that returns a module federation configuration object.
The function will return a different configuration based on the `isServer` property
If the property is falsy the micro-frontend will be loaded from `static/chunks/remoteEntry.js`, otherwise it will be loaded from `static/ssr/remoteEntry.js`

The only property of interest inside the shell configuration is the `remotes`.
The remotes are a key/value pairs.
- The value determines where the `remoteEntry.js` for a particular micro-frontend is hosted.
  - We can see that the first part (`mfOne`) matches the `name` from mf-one's federationConfig followed by .
  - The second part (`@http://localhost:4001`) matches the address where the mf-one micro-frontend server is running.
  - The third part (`static/${ isServer ? "ssr" : "chunks"}/remoteEntry.js`) matches the filename property in mf-one's federationConfig.
- The key determines the path that will be used inside the shell project to import the micro-frontends

#### The FederatedTypesPlugin

This plugin allows us to share types between micro-frontends and their consumers.
It uses the same config as the `NextFederationPlugin`, but in the micro-frontend project the types are only generated inside the `static/chunks/remoteEntry.js`,
this is why we pass `false` in the  `createFederationConfig` function when creating a config for this plugin.

When the shell loads mf-one, a new `@mf-types` folder is also created inside the shell project, containing the type definitions provided by mfOne's `FederatedTypesPlugin`.
To use the types the `compilerOptions.paths` inside the tsconfig.json in the root of the shell project must be updated with the following entry:
```
"@mfe/*": ["./@mf-types/@mfe/*"]
```

This will allow us to import microfrontends using the following pattern `@mfe/microfrontend-name/component-name`.
The keys inside the `remotes` object of the shell must also be prefixed by `@mfe`
